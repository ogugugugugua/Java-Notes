# [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

> 难度中等

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[原地](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`





## 算法推导

如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：

1. 我们希望下一个数**比当前数大**，这样才满足“下一个排列”的定义。因此只需要**将后面的「大数」与前面的「小数」交换**，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。
2. 我们还希望下一个数增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
   1. 在**尽可能靠右的低位**进行交换，需要**从后向前**查找
   2. 将一个 **尽可能小的「大数」** 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
   3. 将「大数」换到前面后，需要将「大数」后面的**所有数重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列

```java
public void nextPermutation(int[] nums) {
        int len = nums.length;
        if (len==0 || len==1) return;
        if (len == 2) {
            int temp = nums[0];
            nums[0] = nums[1];
            nums[1] = temp;
            return;
        }

        int i = len - 2;
        //目的是要找一个尽可能小的[大数]和前面的[小数]进行交换，所以对于那些降序的就直接跳过
        while (i>=0 && nums[i]>=nums[i+1]) i--;       //遇到相邻升序的才停下来，否则继续往左寻找  （推导2.1）
        if (i == -1) {              				//全逆序
            Arrays.sort(nums);      				//按照升序进行一次排序即可
            return;
        }

        Arrays.sort(nums, i + 1, len);      		//后半段的最长降序给调整为升序			 （推导2.3）
        int j = i + 1;
        while (nums[j] <= nums[i]) j++;               //寻找那个尽可能小的[大数]				（推导2.2）
        int temp = nums[j];
        nums[j] = nums[i];
        nums[i] = temp;

    }
```



## 算法过程

- **从后向前**查找第一个**相邻升序**的元素对 (i,j)，满足 A[i] < A[j]。此时 [j,end) 必然是降序
- 如果在找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接把整个序列变位升序并return
- 否则，先将 [j,end)变为升序，方便在 [j,end) **从后向前**查找第一个满足 A[i] < A[k] 的 k。A[i]、A[k] 分别就是上文所说的「小数」、「大数」
- 将 A[i] 与 A[k] 交换





---

作者：imageslr
链接：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

