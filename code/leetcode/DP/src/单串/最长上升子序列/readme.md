# [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> 难度 中等

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 O(*n* log *n*) 吗?

---

输入是一个单串，首先思考单串问题中设计状态` dp[i] `时拆分子问题的方式：枚举子串或子序列的结尾元素来拆分子问题，设计状态` dp[i] := 在子数组 `[0..i] 上，且选了` nums[i] `时，的最长上升子序列。

因为子序列需要上升，因此以` i 结尾的子序列中，`nums[i]` 之前的数字一定要比 `nums[i] `小才行，因此目标就是先找到以此前比 `nums[i] `小的各个元素，然后每个所选元素对应一个以它们结尾的最长子序列，从这些子序列中选择最长的，其长度加 1 就是当前的问题的结果。如果此前没有比` nums[i] `小的数字，则当前问题的结果就是 1 。

按照以上的分析，状态的转移方程可以写出来，如下

$$
dp[i] = max_{j}(dp[j]) + 1
$$
其中
$$
0 \leq j < i, nums[j] < nums[i]
$$
本题依然是单串 dp[i] 的问题，状态的推导方向，以及推导公式与上一题的图示相同，

状态的推导依然是按照` i `从 0 到 `n-1` 推的，计算 `dp[i] `时，`dp[i-1], dp[i-2], ..., dp[0] `依然已经计算完。

但本题与上一题的区别是推导 `dp[i]` 时，`dp[i-1]. dp[i-2], ..., dp[0]` 均可能需要用上，即，因此计算当前的橙色状态时，绿色部分此前计算过的状态都可能需要用上。
