# [918. 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

> 难度 中等

给定一个由整数数组 `A` 表示的**环形数组 `C`**，求 `**C**` 的非空子数组的最大可能和。

在此处，*环形数组*意味着数组的末端将会与开头相连呈环状。（形式上，当`0 <= i < A.length` 时 `C[i] = A[i]`，且当 `i >= 0` 时 `C[i+A.length] = C[i]`）

此外，子数组最多只能包含固定缓冲区 `A` 中的每个元素一次。（形式上，对于子数组 `C[i], C[i+1], ..., C[j]`，不存在 `i <= k1, k2 <= j` 其中 `k1 % A.length = k2 % A.length`）

 

**示例 1：**

```
输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
```

**示例 2：**

```
输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
```

**示例 3：**

```
输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4
```

**示例 4：**

```
输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
```

**示例 5：**

```
输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1
```

 

**提示：**

1. `-30000 <= A[i] <= 30000`
2. `1 <= A.length <= 30000`

---

## 题解

这题和求最大自序和很类似：

1. 对于在数组中间的最大自序和，我们可以照常求出。
2. 对于需要跨界的最大子序和，我们可以根据下图进行反向思考，只需要求出中间的最小子序和，然后用总和来相减即可。

所以只需要判断【中间最大子序和】和【sum-中间最小子序和】哪个大即可。

需要**注意**的是，最小子序和的计算区间不包括最后一位，因为只有这样才有意义（若最小子序和数组全选了，就相当于在最大子序和数组中一个都没选，这样不符合返回值的要求）

![](https://pic.leetcode-cn.com/db5a2b3733b878ffd26b12c079db767a61d92423b8bd0e3fcf0a6443894842d8-image.png)

```java
public int maxSubarraySumCircular(int[] A) {
        int[] dpMax = new int[A.length];
        int[] dpMin = new int[A.length];
        int max = A[0], sum = 0;
        for (int i : A) {
            sum += i;
        }
        dpMax[0] = A[0];
        dpMin[0] = A[0];
        for (int i = 1; i < A.length; i++) {
            dpMax[i] = Math.max(dpMax[i - 1], 0) + A[i];
            dpMin[i] = (i == A.length - 1) ? dpMin[i - 1] : Math.min(dpMin[i - 1], 0) + A[i];
            max = Math.max(Math.max(max, dpMax[i]), sum - dpMin[i]);
        }
        return max;
    }
```

