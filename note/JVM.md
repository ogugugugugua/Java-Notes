# JVM笔记

## 常见面试题：

1. 请谈谈对JVM的理解？java8虚拟机和之前的变化更新？
2. 什么是OOM？什么是栈溢出StackOverFlowError？怎么分析？
3. JVM的常用调优参数有哪些？
4. 内存快照如何抓取？怎么分析Dump文件？
5. 谈谈JVM中，类加载器的认识？

---

## JVM的位置

基于操作系统之上，相当于一个环境。

---

## JVM的体系结构

下图中绿色区域为线程共享数据，黄色区域为线程私有数据。

![未命名文件](https://user-images.githubusercontent.com/17522733/93140660-1cd5bc80-f6e3-11ea-8057-1746f222bb97.png)

显然黄色区域的栈、本地方法栈、程序计数器这三个线程私有数据并**不会**有垃圾回收的问题。

因此所谓的**JVM调优**，都会集中在**堆**和方法区那里，方法区可以看成是一个特殊的堆。

---

## 类加载器

### 作用：

加载.class文件。查看方法是`.getClassLoader()`

### 过程：

1. 类加载器收到类加载的请求
2. 将这个请求向上委托给父类加载器去完成，一直向上委托直到启动类加载器ROOT
3. 启动加载器检查是否能够加载当前该类，能加载就搞定结束，否则抛出异常通知子加载器进行加载
4. 重复步骤3

### 类别：

- 虚拟机自带的加载器
- 启动类的加载器/根加载器
- 扩展类加载器 `ExtClassLoader`
- 应用程序加载器 `AppClassLoader`

---

## 双亲委派机制

用于保证安全。会逐层往下寻找类的所在包，比如先在ROOT根加载器中找，然后再去EXT扩展类加载器中找，最后在APP应用程序加载器中找，如果APP和ROOT中有同名包，则会优先执行ROOT中的那个。

---

## 沙箱安全机制

组成沙箱的基本组件：

- 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。帮助实现内存保护。
- 类装载器（Class loader）：其在3个方面对Java沙箱其作用：
  - 防止恶意代码去干涉善意代码		//双亲委派机制
  - 守护了被信任的类库边界
  - 将代码归入保护域，确定了代码可以进行哪些操作

---

## Native

典型如`new Thread().start()`函数中有一行：`private native void start0();` 即为native函数。

凡是带了native关键字的方法，说明java的作用范围达不到了，会去调用底层C语言的库。这些函数都会进入**本地方法栈**，调用本地方法接口，即JNI。 

---

## PC寄存器

program counter register

每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区的方法字节码，在执行引擎读取下一条指令。用于线程切换出去和切换回来时，找到原来的执行位置。

---

## 方法区

Method area

被所有线程共享的，包含所有字段和方法字节码，以及一些特殊方法，比如构造函数，接口代码也在这里定义。即所有定义的方法的信息都保存在这个区域。

**静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关。**

---

## 栈VS堆 

栈：FILO。线程结束，栈内存就释放，故对于栈来说不存在垃圾回收。

栈运行原理：栈帧。程序正在执行的方法一定在栈的顶部。栈满就会有StackOverFlowError。

栈，堆的交互关系：栈中的引用指向堆中的对象具体的实例。堆中的常量指向元空间中常量池里的东西。

![image-20200915211525421](https://user-images.githubusercontent.com/17522733/93254468-ab584580-f798-11ea-957d-e6ea90e0d372.png)

**画出在内存中一个对象实例化的过程。**

---

## 三种JVM

## 新生区VS老年区VS永久区

## 堆内存调优

## GC常用算法

## JMM