# 多线程与高并发1

进程 线程 协程

线程是进程的最小执行单元

一个程序里不同的执行路径可以理解为线程

---



启动线程的3种方法：

继承Thread并重写run方法

实现Runnable接口并重写run方法

通过lambda方法来启动   或者   通过线程池Executor.newCachedThread来进行启动线程

---



yield让出CPU并进入等待状态

t1线程里面调用t2.join()，会去执行t2，搞定之后回来继续执行t1

![多线程状态转移图 (1)](https://user-images.githubusercontent.com/17522733/97427594-14dd7f00-1915-11eb-90a6-17b69d8f4f34.png)

不要尝试去手动关闭线程，要让其正常结束

出现异常的时候正常会释放锁，所以需要格外小心，以免一个线程的脏数据在异常后被另一个线程读到

---



synchronized的底层实现：

JDK早期的时候是重量级的，需要调用OS的方法

后来做了改进，锁升级的概念：

- 如果当前只有一个线程想要对某个对象占用锁的话，直接在该对象的头部markword记录这个线程的ID，此为偏向锁。若同一把锁重入，就可以很方便地检查markword中记录的ID是否和自己一样，一样的话就直接执行，很快速方便。

- 如果有线程争用，则升级为自旋锁，等待的线程会反复查询该对象的锁是否已经被释放。

- 在自旋查询10次以后，升级为重量级锁，调用OS的方法，进入到等待队列中。这个线程就进入了等待状态，不占用CPU资源。

---

什么时候使用自旋锁更好？

自旋锁不会调用OS的方法，一直处于用户态而不进入内核态，但会占用CPU的资源

因此对于执行时间长的任务建议使用OS锁，也就是synchronized。

对于执行时间短的任务可以使用自旋锁，但是需要保证等待的任务数不能过多，否则会CPU会受不了。

总结：

- 加锁的代码执行时间长，线程数多，使用重量级锁synchronized。  
- 加锁的代码任务执行时间短，线程数少，使用自旋锁。

---

# 多线程与高并发2

volatile作用：

- 保证线程可见性 
- 禁止指令重排序

单例模式，懒汉生成法，要保证线程安全【双重检查】：

```java
public class test{
    private static volatile test INSTANCE; //要加volatile，原因解释在下方
    private test(){}
    public getInstance(){
        if(INSTANCE==null){	//判断的时候先不加锁
            synchronized (test.class){
                if(INSTANCE==null){	//上一次判断后，要加锁，在new之前，看看在此期间是否有被别的线程抢占了锁并已经new出来了对象
                    INSTANCE=new test();
                }
            }
        }
        return INSTANCE;	//返回单例
    }
    public void someFunctions(){
        System.out.println("some functions.");
    }
    public static void main(String[] args){
        for(int i = 0; i<100; i++){
            new Thread(()->{
                System.out.println(test.getInstance().hashcode());
            }).start();
        }
    }
}
```

问题：双重检查写法的单例模式是否要加volatile？

答案：要的。

INSTANCE=new test();这一句话在JVM中有三个步骤：1. 申请内存（带有默认值）。2. 设置成员的值。3. 让引用指向内存的地址。

在不加volatile的情况下，上述的第2第3个步骤可能会进行指令重拍，也就是：申请内存->引用指向内存地址->设置成员的值。

在超高并发的场景下，线程A在new的过程中申请了带有默认值的内存，并把引用指向了该地址，还没来得及修改成员的值。此时线程B查看INSTANCE不为空，直接返回该单例并使用。在这种情况下，线程B拿到的成员的值是不对的，因为线程A还没有正确地初始化它。

加了volatile之后指令重排序不被允许，那么线程A在new的过程中就可以保证成员的值被正确初始化后才赋值给引用，就不会出现上述的问题了。

结论：双重检查写法的单例模式要加volatile。



---

synchronized优化

锁的细化，只加在需要锁的那部分代码。

如果synchronized对某个对象进行锁，那么建议那个对象添加修饰词final，以避免出现对象引用变化的情况。

不要用String类型来作为锁的对象。

---

CAS compare and swap/set 

无锁优化 或者叫 乐观锁。

AtomicInteger可以实现。

ABA问题解决：加版本号。修改一次版本号加一，检查的时候包括值本身和版本号。AtomicStampedReference类可以做到。

其实对于基本数据类型并没有问题，对于引用类型需要留意。

---

# 多线程与高并发3

LongAdder 分段锁。

ReentrantLock的使用可以替代synchronized：在原来使用synchronized(this)的地方换成reentrantLock.lock()，然后记得最后要reentrantLock.unlock()。同时要注意把lock()写在try里面，unlock()写在finally里面。以避免出现异常而无法正常释放锁。

ReentrantLock有一些比synchronized要强大的地方，比如：

- 可以尝试锁，自行决定等待锁时间：

  ```java
  Lock lock = new ReentrantLock();
  try {
      lock.tryLock(6, TimeUnit.MILLISECONDS);
  } catch (InterruptedException e) {
      e.printStackTrace();
  }finally {
      lock.unlock();
  }
  ```

- 可以被打断的加锁

  ```java
  Lock lock = new ReentrantLock();
  try {
      lock.lockInterruptibly();
  } catch (InterruptedException e) {
      e.printStackTrace();
  }finally {
      lock.unlock();
  }
  ```

- 可以实现公平锁：即先到先得，最后来的锁不能马上抢到对象，而是要进入等待队列中排队

  ```java
  Lock lock1 = new ReentrantLock(true);
  ```

---

CyclicBarrier

一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。

应用场景
在某种需求中，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择CyclicBarrier了。具体地，一个请求过来之后需要先进行数据库操作+文件操作+计算操作，这三者可以使用三个线程来同步执行，当这三个任务都执行完成后，执行一个渲染页面任务，此时可以在前三者的任务代码中调用CyclicBarrier的await()方法，然后把最后一个任务内容写在CyclicBarrier的Runnable里面。

> CyclicBarrier好比一扇门，默认情况下关闭状态，堵住了线程执行的道路，直到所有线程都就位，门才打开，让所有线程一起通过。

```java
CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() {
    @Override
    public void run() {
        System.out.println("run application");		//主任务
    }
});

Runnable runnable = new Runnable() {				//子任务
    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName());
            barrier.await();						//子任务中await一次CyclicBarrier
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
};

for (int i = 0; i < 3; i++) {
    new Thread(runnable,"Thread"+i).start();
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

---

读写锁ReadWriteLock

对于一些读操作频繁而写操作不频繁的业务来说有巨大的性能提升。由ReentrantReadWriteLock类提供。

```java
public static void main(String[] args) {
    ReentrantLock lock = new ReentrantLock();
    ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    for (int i = 0; i < 20; i++) {
        new Thread(()->read(readLock)).start();		//这里传入readLock就会迅速执行完毕，若传入lock则会有漫长的等待
    }
    for (int i = 0; i < 2; i++) {
        new  Thread(()->write(writeLock)).start();
    }
}

public static void read(Lock lock) {
    lock.lock();
    try {
        System.out.println("read");
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

public static void write(Lock lock) {
    lock.lock();
    try {
        System.out.println("write");
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }finally {
        lock.unlock();
    }
}
```

---

semaphore

可以用来【限流】。

无论有多少个线程活跃着，能运行的（获取到锁）只有permits限定的这么多个。每次acquire就会使得permits减一，每次release就会加一。

可以形象地理解成车道和收费站的关系。

---

# 多线程与高并发4

> [淘宝面试题1](https://github.com/ogugugugugua/Java-Notes/tree/2237b94422e32529f6a1825a3023975be95c560c/code/multiThread/src/com/interviewExercises/ex1)：实现一个容器，提供两个方法add size，写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束

解法详解：

- T01并不能用，因为线程1更改的内容对于线程2来说并不可见。
- T02和T03本质上属于在T01基础上增加了volatile关键字，虽然可行但是很奇怪：volatile修饰的是指向内存地址的指针，而这个指针是不会随着内存中值的修改而变化的，所以并不能合理地解释为什么线程1修改的值能够及时让线程2感知到。暂时放下不表。
- T04也不能用。因为notify不释放锁，所以线程1即使唤醒了线程2，但是并没有释放掉锁，线程2只能等着。
- T05是真正可用的版本，需要背下来，这是最基础原始的写法。线程1在容器到达指定size的时候通知线程2的同时需要把自己停掉，等线程2执行完之后再唤醒线程1。
- T06与T05在思想上高度雷同，但是使用了两个CountDownLatch这个工具，使得原来的wait方法变成了latch.wait，原来的notify方法变成了latch.countDown方法。
- T07是最简洁的版本，同样与T05在思想上高度雷同，使用了LockSupport工具，使用park方法代替wait来停住自己，使用unpark方法代替notify来唤醒另外一个线程。





> [淘宝面试题2](https://github.com/ogugugugugua/Java-Notes/tree/2237b94422e32529f6a1825a3023975be95c560c/code/multiThread/src/com/interviewExercises/ex2)：写一个固定容量同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程和10个消费者线程的阻塞调用。

- 这是经典的题目，需要直接背好解题。
- 需要注意的是需要使用while来判断当前size和最大/最小限制的关系。
- T01是比较高效的版本，由于引入了Condition这个工具，只会唤醒指定线程队列里面的等待队列。

---

LockSupport

unpark可以在park前调用，以失效即将到来的park。可以看出比wait和notify更灵活。

---

Condition的本质就是等待队列！

---

AQS	AbstractQueuedSynchronizer 是很重要的类，需要仔细阅读源码

模板方法 钩子函数; template method, callback function