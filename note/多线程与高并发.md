# 多线程与高并发1

进程 线程 协程

线程是进程的最小执行单元

一个程序里不同的执行路径可以理解为线程

---



启动线程的3种方法：

继承Thread并重写run方法

实现Runnable接口并重写run方法

通过lambda方法来启动   或者   通过线程池Executor.newCachedThread来进行启动线程

---



yield让出CPU并进入等待状态

t1线程里面调用t2.join()，会去执行t2，搞定之后回来继续执行t1

![多线程状态转移图 (1)](https://user-images.githubusercontent.com/17522733/97427594-14dd7f00-1915-11eb-90a6-17b69d8f4f34.png)

不要尝试去手动关闭线程，要让其正常结束

出现异常的时候正常会释放锁，所以需要格外小心，以免一个线程的脏数据在异常后被另一个线程读到

---



synchronized的底层实现：

JDK早期的时候是重量级的，需要调用OS的方法

后来做了改进，锁升级的概念：

- 如果当前只有一个线程想要对某个对象占用锁的话，直接在该对象的头部markword记录这个线程的ID，此为偏向锁。若同一把锁重入，就可以很方便地检查markword中记录的ID是否和自己一样，一样的话就直接执行，很快速方便。

- 如果有线程争用，则升级为自旋锁，等待的线程会反复查询该对象的锁是否已经被释放。

- 在自旋查询10次以后，升级为重量级锁，调用OS的方法，进入到等待队列中。这个线程就进入了等待状态，不占用CPU资源。

---

什么时候使用自旋锁更好？

自旋锁不会调用OS的方法，一直处于用户态而不进入内核态，但会占用CPU的资源

因此对于执行时间长的任务建议使用OS锁，也就是synchronized。

对于执行时间短的任务可以使用自旋锁，但是需要保证等待的任务数不能过多，否则会CPU会受不了。

总结：

- 加锁的代码执行时间长，线程数多，使用重量级锁synchronized。  
- 加锁的代码任务执行时间短，线程数少，使用自旋锁。

---

# 多线程与高并发2

volatile作用：

- 保证线程可见性 
- 禁止指令重排序

单例模式，懒汉生成法，要保证线程安全【双重检查】：

```java
public class test{
    private static volatile test INSTANCE; //要加volatile，原因解释在下方
    private test(){}
    public getInstance(){
        if(INSTANCE==null){	//判断的时候先不加锁
            synchronized (test.class){
                if(INSTANCE==null){	//上一次判断后，要加锁，在new之前，看看在此期间是否有被别的线程抢占了锁并已经new出来了对象
                    INSTANCE=new test();
                }
            }
        }
        return INSTANCE;	//返回单例
    }
    public void someFunctions(){
        System.out.println("some functions.");
    }
    public static void main(String[] args){
        for(int i = 0; i<100; i++){
            new Thread(()->{
                System.out.println(test.getInstance().hashcode());
            }).start();
        }
    }
}
```

问题：双重检查写法的单例模式是否要加volatile？

答案：要的。

INSTANCE=new test();这一句话在JVM中有三个步骤：1. 申请内存（带有默认值）。2. 设置成员的值。3. 让引用指向内存的地址。

在不加volatile的情况下，上述的第2第3个步骤可能会进行指令重拍，也就是：申请内存->引用指向内存地址->设置成员的值。

在超高并发的场景下，线程A在new的过程中申请了带有默认值的内存，并把引用指向了该地址，还没来得及修改成员的值。此时线程B查看INSTANCE不为空，直接返回该单例并使用。在这种情况下，线程B拿到的成员的值是不对的，因为线程A还没有正确地初始化它。

加了volatile之后指令重排序不被允许，那么线程A在new的过程中就可以保证成员的值被正确初始化后才赋值给引用，就不会出现上述的问题了。

结论：双重检查写法的单例模式要加volatile。



---

synchronized优化

锁的细化，只加在需要锁的那部分代码。

如果synchronized对某个对象进行锁，那么建议那个对象添加修饰词final，以避免出现对象引用变化的情况。

不要用String类型来作为锁的对象。

---

CAS compare and swap/set 

无锁优化 或者叫 乐观锁。

AtomicInteger可以实现。

ABA问题解决：加版本号。修改一次版本号加一，检查的时候包括值本身和版本号。AtomicStampedReference类可以做到。

其实对于基本数据类型并没有问题，对于引用类型需要留意。

---

