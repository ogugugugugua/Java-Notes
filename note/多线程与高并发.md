# 多线程与高并发1

进程 线程 协程

线程是进程的最小执行单元

一个程序里不同的执行路径可以理解为线程



启动线程的3种方法：

继承Thread并重写run方法

实现Runnable接口并重写run方法

通过lambda方法来启动   或者   通过线程池Executor.newCachedThread来进行启动线程



yield让出CPU并进入等待状态

t1线程里面调用t2.join()，会去执行t2，搞定之后回来继续执行t1

![多线程状态转移图 (1)](https://user-images.githubusercontent.com/17522733/97427594-14dd7f00-1915-11eb-90a6-17b69d8f4f34.png)

不要尝试去手动关闭线程，要让其正常结束

出现异常的时候正常会释放锁，所以需要格外小心，以免一个线程的脏数据在异常后被另一个线程读到



synchronized的底层实现：

JDK早期的时候是重量级的，需要调用OS的方法

后来做了改进，锁升级的概念：

​	如果当前只有一个线程想要对某个对象占用锁的话，直接在该对象的头部markword记录这个线程的ID，此为偏向锁。若同一把锁重入，就可以很方便地检查markword中记录的ID是否和自己一样，一样的话就直接执行，很快速方便。

​	如果有线程争用，则升级为自旋锁，等待的线程会反复查询该对象的锁是否已经被释放。

​	在自旋查询10次以后，升级为重量级锁，调用OS的方法，进入到等待队列中。这个线程就进入了等待状态，不占用CPU资源。



什么时候使用自旋锁更好？

自旋锁不会调用OS的方法，一直处于用户态而不进入内核态，但会占用CPU的资源

因此对于执行时间长的任务建议使用OS锁，也就是synchronized。

对于执行时间短的任务可以使用自旋锁，但是需要保证等待的任务数不能过多，否则会CPU会受不了。

总结：

- 加锁的代码执行时间长，线程数多，使用重量级锁synchronized。  
- 加锁的代码任务执行时间短，线程数少，使用自旋锁。