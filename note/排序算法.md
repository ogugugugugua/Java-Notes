# 快速排序

## 示意图

![quicksort](https://user-gold-cdn.xitu.io/2018/7/23/164c596d5fb34fd3?imageslim)

## 基本思想：**挖坑填数 + 分治法**

1. 从序列中取出一个数作为基准数
2. 分区过程：将比这个数大的数全部放到它的右边，小于或等于它的数全部放到它的左边
3. 递归地对左右子序列尽心步骤2，直到各区间只有一个数

---



## 举例

我们这里有初始数组如下

| i=0  |  1   |  2   |  3   |  4   |  5   |  6   | j=7  |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| (49) |  38  |  65  |  97  |  76  |  13  |  27  |  49  |

对于这个算法，我们需要两个变量`i`和`j`分别代表数组的两端，这两个变量将会分别往中间靠拢。

约定取当前区间的第一个元素为`index`作为参考，即`index = arr[i] = arr[0] = 49`。

这时`i=0`的地方就已经挖了一个坑。我们从数组的右端开始往左遍历`j`，找出比`index`小的数`arr[j]`，填到`arr[i]`即 `arr[0]`的位置；

显然当`j=6`时满足`arr[6]<index`，所以按照上一行的解释`arr[0] = arr[i] = arr[j] = arr[6] = 27`，并且`i++`，数组变成：

|  0   | i=1  |  2   |  3   |  4   |  5   | j=6  |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  |  65  |  97  |  76  |  13  | (27) |  49  |

这时`j=6`的地方就挖了一个坑。我们从数组的左端开始往右遍历`i`，找出比`index`大的数`arr[i]`，填到`arr[j]`即`arr[6]`的位置；

显然当`i=2`的时候满足`arr[2]>index`，所以按照上一行的解释`arr[6] = arr[j] = arr[i] = arr[2] = 65`，并且`j--`，数组变成：

|  0   |  1   | i=2  |  3   |  4   | j=5  |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  | (65) |  97  |  76  |  13  |  65  |  49  |

这是`i=2`的地方就被挖出一个坑。

再重复上面的步骤，**先从后往前找，再从前往后找**。

从`j`开始往前找，当`j=5`时，符合条件，将`arr[5]`挖出一个坑，`arr[i] = arr[2]`的坑被填上，并且`i++`，数组变成：。

|  0   |  1   |  2   | i=3  |  4   | j=5  |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  |  13  |  97  |  76  | (13) |  65  |  49  |

从`i`开始往后找，当`i=3`时，符合条件，将`arr[3]`挖出一个坑，`arr[j] = arr[5]`的坑被填上，并且`j--`，数组变成：。

|  0   |  1   |  2   | i=3  | j=4  |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  27  |  38  |  13  | (97) |  76  |  97  |  65  |  49  |

从`j`开始往前找，此时`i==3,j==4`，由于要保持`i<j`这个条件，所以无法再继续找到合适的元素。

这时只需要把`index`填回去`arr[i]`这个坑即可：

|  0   |  1   |  2   |    3     |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :------: | :--: | :--: | :--: | :--: |
|  27  |  38  |  13  | index=49 |  76  |  97  |  65  |  49  |

通过上面这一轮可以看出，`arr[3]`前面的数字都小于它，`arr[3]`后面的数字都大于它。

只需要对`arr[0...2]`和`arr[4....7]`这两个子区间重复上述步骤即可。

---



## 对挖坑填数进行总结

1．i = L; j = R; 将基准数挖出形成第一个坑 a[i]。

2．j-- 由后向前找比它小的数，找到后挖出此数填前一个坑 a[i] 中。

3．i++ 由前向后找比它大的数，找到后也挖出此数填到前一个坑 a[j] 中。

4．再重复执行 2，3 二步，直到 i==j，将基准数填入 a[i] 中。

